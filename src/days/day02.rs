use std::{collections::HashSet, ops::RangeInclusive};

use nom::{
    Parser,
    bytes::complete::tag,
    character::complete::{newline, u64 as parse_u64},
    combinator::opt,
    multi::separated_list1,
    sequence::{separated_pair, terminated},
};

use crate::NumUtil;
use crate::util::Answer;

pub fn solve(input: &str) -> anyhow::Result<String> {
    let ranges = parse_input(input)?;
    let p1 = sum_invalid(&ranges, part_one_sum_all_multiples);
    let p2 = sum_invalid(&ranges, part_two_sum_all_multiples);
    Answer::first(2, p1).second(p2).report()
}

fn parse_input(s: &str) -> anyhow::Result<Vec<RangeInclusive<u64>>> {
    let mut parser = terminated(
        separated_list1(
            tag(","),
            separated_pair(
                parse_u64::<&str, nom::error::Error<&str>>,
                tag("-"),
                parse_u64,
            ),
        ),
        opt(newline),
    );
    let (leftover, pairs) = parser.parse(s).map_err(|e| e.to_owned())?;
    if !leftover.is_empty() {
        anyhow::bail!("Did not parse complete input, leftover: {leftover:?}");
    }
    let ranges = pairs.into_iter().map(|(start, end)| start..=end).collect();
    Ok(ranges)
}

pub fn sum_invalid(ranges: &[RangeInclusive<u64>], f: fn(&RangeInclusive<u64>) -> u64) -> u64 {
    ranges.iter().map(f).sum()
}

fn generate_multiples(pattern: u64, start: u64) -> impl Iterator<Item = u64> {
    (start..).map(move |x| pattern * x)
}

fn sum_single_pattern(pattern: u64, start: u64, n_digits: u32, range: &RangeInclusive<u64>) -> u64 {
    generate_multiples(pattern, start)
        .skip_while(move |m| m < range.start())
        .take_while(move |m| m <= range.end() && *m < 10u64.pow(n_digits))
        .sum()
}

fn part_one_sum_all_multiples(range: &RangeInclusive<u64>) -> u64 {
    let start_n_digits = range.start().n_digits();
    let end_n_digits = range.end().n_digits();
    // Number of digits, pattern, start at n multiples.
    [
        (2, 11, 1),
        (4, 101, 10),
        (6, 1001, 100),
        (8, 10001, 1000),
        (10, 100_001, 10_000),
    ]
    .into_iter()
    .skip_while(|(n, ..)| *n < start_n_digits)
    .take_while(|(n, ..)| *n <= end_n_digits)
    .map(|(n_digits, pattern, start)| sum_single_pattern(pattern, start, n_digits, range))
    .sum()
}

fn part_two_sum_all_multiples(range: &RangeInclusive<u64>) -> u64 {
    let start_n_digits = range.start().n_digits();
    let end_n_digits = range.end().n_digits();
    // Number of digits, &[(pattern, start at n multiples)]
    let source: [(u32, &[(u64, u64)]); 9] = [
        (2, &[(11, 1)]),
        (3, &[(111, 1)]),
        (4, &[(101, 10)]),
        (5, &[(11_111, 1)]),
        (6, &[(1001, 100), (10_101, 10)]),
        (7, &[(1_111_111, 1)]),
        (8, &[(10_001, 1000), (1_010_101, 10)]),
        (9, &[(111_111_111, 1), (1_001_001, 100)]),
        (10, &[(100_001, 10_000), (101_010_101, 10)]),
    ];
    let applicable = source
        .into_iter()
        .skip_while(|(n, ..)| *n < start_n_digits)
        .take_while(|(n, ..)| *n <= end_n_digits);

    let mut total = 0;
    for (n_digits, pattern_pairs) in applicable {
        if let &[(pattern, start)] = pattern_pairs {
            total += sum_single_pattern(pattern, start, n_digits, range);
        } else {
            // Can't just sum the possible multiples in case the same number is
            // generated by two different patterns, eg 222,222 => 1,001 & 10,101.
            let mut seen =
                HashSet::with_capacity_and_hasher(256, foldhash::fast::RandomState::default());
            let limit = 10u64.pow(n_digits);
            for &(pattern, start) in pattern_pairs {
                generate_multiples(pattern, start)
                    .skip_while(|multiple| multiple < range.start())
                    .take_while(|multiple| multiple <= range.end() && *multiple < limit)
                    .for_each(|multiple| {
                        seen.insert(multiple);
                    });
            }
            total += seen.iter().sum::<u64>();
        }
    }
    total
}

#[cfg(test)]
mod test {
    use super::{parse_input, part_one_sum_all_multiples, part_two_sum_all_multiples, sum_invalid};

    static TEST_INPUT: &str = "11-22,95-115,998-1012,1188511880-1188511890,222220-222224,1698522-1698528,446443-446449,38593856-38593862,565653-565659,824824821-824824827,2121212118-2121212124";

    #[test]
    fn parse_test_input() -> anyhow::Result<()> {
        let res = parse_input(TEST_INPUT)?;
        let expected = vec![
            (11..=22),
            (95..=115),
            (998..=1012),
            (1188511880..=1188511890),
            (222220..=222224),
            (1698522..=1698528),
            (446443..=446449),
            (38593856..=38593862),
            (565653..=565659),
            (824824821..=824824827),
            (2121212118..=2121212124),
        ];
        assert_eq!(res, expected);
        Ok(())
    }

    #[test]
    pub fn part_one_test_input() -> anyhow::Result<()> {
        let ranges = parse_input(TEST_INPUT)?;
        let result = sum_invalid(&ranges, part_one_sum_all_multiples);
        assert_eq!(result, 1227775554);
        Ok(())
    }

    #[test]
    pub fn part_one_known_answer() -> anyhow::Result<()> {
        let ranges = parse_input(crate::days::get_input(2).unwrap())?;
        let result = sum_invalid(&ranges, part_one_sum_all_multiples);
        assert_eq!(result, 18595663903);
        Ok(())
    }

    #[test]
    pub fn part_two_test_input() -> anyhow::Result<()> {
        let ranges = parse_input(TEST_INPUT)?;
        let result = sum_invalid(&ranges, part_two_sum_all_multiples);
        assert_eq!(result, 4174379265);
        Ok(())
    }

    #[test]
    pub fn part_two_known_answer() -> anyhow::Result<()> {
        let ranges = parse_input(crate::days::get_input(2).unwrap())?;
        let result = sum_invalid(&ranges, part_two_sum_all_multiples);
        assert_eq!(result, 19058204438);
        Ok(())
    }
}
